"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var generator_options_1 = require("../generator-options");
var codepoints_1 = require("../../utils/codepoints");
var getCodepointsMock = codepoints_1.getCodepoints;
jest.mock('../../types/misc', function () { return ({
    FontAssetType: { TTF: 'TTF', EOT: 'eot' },
    OtherAssetType: { CSS: 'css', HTML: 'html' },
    ASSET_TYPES: { ttf: 'ttf', eot: 'eot', css: 'css', html: 'html' }
}); });
jest.mock('../../utils/codepoints', function () { return ({
    getCodepoints: jest.fn(function () { return ({ __mock: 'processed-codepoint__' }); })
}); });
describe('Font generator options', function () {
    beforeEach(function () {
        getCodepointsMock.mockClear();
    });
    test('`prefillOptions` correctly extends default values for each type and prefills missing ones', function () {
        expect(generator_options_1.prefillOptions({ html: { a: 'a', c: 'c' } }, { ttf: { foo: 'default' }, html: { b: 'b', c: 'override-me' } })).toEqual({
            ttf: { foo: 'default' },
            eot: {},
            css: {},
            html: { a: 'a', b: 'b', c: 'c' }
        });
    });
    test('`getGeneratorOptions` produces usable font generator options including given `assets` and sanitised `formatOptions`', function () {
        var outputDir = '/dev/null';
        var formatOptions = { eot: { foo: 'bar' } };
        var pathOptions = { eot: 'test' };
        var options = {
            __mock: 'assetsMap__',
            outputDir: outputDir,
            formatOptions: formatOptions,
            pathOptions: pathOptions
        };
        var assets = { __mock: 'runnerOptions__' };
        expect(generator_options_1.getGeneratorOptions(options, assets)).toEqual(__assign(__assign({}, options), { assets: assets, codepoints: { __mock: 'processed-codepoint__' }, formatOptions: {
                ttf: {},
                eot: { foo: 'bar' },
                css: {},
                html: {}
            } }));
    });
    test('`getGeneratorOptions` calls `getCodepoints` with input assets and codepoints', function () {
        var codepointsIn = { foo: 'bar' };
        var options = { codepoints: codepointsIn };
        var assets = {};
        generator_options_1.getGeneratorOptions(options, assets);
        expect(getCodepointsMock).toHaveBeenCalledTimes(1);
        expect(getCodepointsMock).toHaveBeenCalledWith(assets, codepointsIn);
    });
});
//# sourceMappingURL=generator-options.js.map