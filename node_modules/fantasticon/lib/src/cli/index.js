"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var commander_1 = __importDefault(require("commander"));
var misc_1 = require("../types/misc");
var config_loader_1 = require("./config-loader");
var constants_1 = require("../constants");
var runner_1 = require("../core/runner");
var validation_1 = require("../utils/validation");
var logger_1 = require("./logger");
var _a = require('../../package.json'), bin = _a.bin, packageName = _a.name, version = _a.version;
var getCommandName = function () { return (bin && Object.keys(bin)[0]) || packageName; };
var cli = function () { return __awaiter(void 0, void 0, void 0, function () {
    var input, _a, debug, silent, configPath, logger, _b, loadedConfig, loadedConfigPath, results, _c, error_1;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                config();
                input = commander_1["default"].program.parse(process.argv);
                _a = input.opts(), debug = _a.debug, silent = _a.silent, configPath = _a.config;
                logger = logger_1.getLogger(debug, silent);
                _d.label = 1;
            case 1:
                _d.trys.push([1, 5, , 6]);
                return [4 /*yield*/, config_loader_1.loadConfig(configPath)];
            case 2:
                _b = _d.sent(), loadedConfig = _b.loadedConfig, loadedConfigPath = _b.loadedConfigPath;
                _c = run;
                return [4 /*yield*/, buildOptions(input, loadedConfig)];
            case 3: return [4 /*yield*/, _c.apply(void 0, [_d.sent()])];
            case 4:
                results = _d.sent();
                logger.start(loadedConfigPath);
                logger.results(results);
                return [3 /*break*/, 6];
            case 5:
                error_1 = _d.sent();
                logger.error(error_1);
                process.exitCode = 1;
                return [3 /*break*/, 6];
            case 6: return [2 /*return*/];
        }
    });
}); };
var printList = function (available, defaults) {
    return " (default: " + defaults.join(', ') + ", available: " + Object.values(available).join(', ') + ")";
};
var printDefaultValue = function (value) {
    var printVal = String(value);
    if (typeof value === 'undefined') {
        return '';
    }
    return " (default: " + printVal + ")";
};
var printDefaultOption = function (key) {
    return printDefaultValue(constants_1.DEFAULT_OPTIONS[key]);
};
var printConfigPaths = function () { return config_loader_1.DEFAULT_FILEPATHS.join(' | '); };
var config = function () {
    commander_1["default"].program
        .storeOptionsAsProperties(false)
        .passCommandToAction(false)
        .name(getCommandName())
        .version(version)
        .arguments('[input-dir]')
        .option('-c, --config <value>', "custom config path (default: " + printConfigPaths() + ")")
        .option('-o, --output <value>', 'specify output directory')
        .option('-n, --name <value>', 'base name of the font set used both as default asset name and classname prefix' +
        printDefaultOption('name'))
        .option('-t, --font-types <value...>', "specify font formats to generate" +
        printList(misc_1.FontAssetType, constants_1.DEFAULT_OPTIONS.fontTypes))
        .option('-g --asset-types <value...>', "specify other asset types to generate" +
        printList(misc_1.OtherAssetType, constants_1.DEFAULT_OPTIONS.assetTypes))
        .option('-h, --font-height <value>', 'the output font height (icons will be scaled so the highest has this height)' +
        printDefaultOption('fontHeight'))
        .option('--descent <value>', 'the font descent' + printDefaultOption('descent'))
        .option('--normalize [bool]', 'normalize icons by scaling them to the height of the highest icon' +
        printDefaultOption('normalize'))
        .option('-r, --round [bool]', 'setup the SVG path rounding [10e12]')
        .option('--selector <value>', "use a CSS selector instead of 'tag + prefix'" +
        printDefaultOption('selector'))
        .option('--tag <value>', 'CSS base tag for icons' + printDefaultOption('tag'))
        .option('-u, --fonts-url <value>', 'public url to the fonts directory (used in the generated CSS)')
        .option('--debug', 'display errors stack trace' + printDefaultValue(false))
        .option('--silent', 'run with no logs' + printDefaultValue(false));
};
var buildOptions = function (cmd, loadedConfig) {
    if (loadedConfig === void 0) { loadedConfig = {}; }
    return __awaiter(void 0, void 0, void 0, function () {
        var inputDir, opts;
        return __generator(this, function (_a) {
            inputDir = cmd.args[0];
            opts = cmd.opts();
            return [2 /*return*/, __assign(__assign({}, loadedConfig), validation_1.removeUndefined({
                    inputDir: inputDir,
                    outputDir: opts.output,
                    name: opts.name,
                    fontTypes: opts.fontTypes,
                    assetTypes: opts.assetTypes,
                    fontHeight: opts.fontHeight,
                    descent: opts.descent,
                    normalize: opts.normalize,
                    round: opts.round,
                    selector: opts.selector,
                    tag: opts.tag,
                    fontsUrl: opts.fontsUrl
                }))];
        });
    });
};
var run = function (options) { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {
    switch (_a.label) {
        case 0: return [4 /*yield*/, runner_1.generateFonts(options, true)];
        case 1: return [2 /*return*/, _a.sent()];
    }
}); }); };
cli();
//# sourceMappingURL=index.js.map